(* generated by Ott 0.25, locally-nameless lngen from: systemt_finite.ott *)
Require Import Metatheory.
(** syntax *)
Definition tmvar := var. (*r variables *)
Definition label := nat.
Definition index := nat.

Inductive typ : Set :=  (*r types *)
 | typ_nat : typ (*r Natural numbers *)
 | typ_arr (t1:typ) (t2:typ) (*r Function types *)
 | typ_unit : typ (*r Unit type *)
 | typ_prod (t1:typ) (t2:typ) (*r Product types *)
 | typ_void : typ (*r Void types *)
 | typ_sum (t1:typ) (t2:typ) (*r Sum types *).

Definition env : Set := list ( atom * typ ).

Inductive exp : Set :=  (*r expressions *)
 | var_b (_:nat) (*r Variables *)
 | var_f (x:atom) (*r Variables *)
 | z : exp (*r Zero *)
 | s (e:exp) (*r Successor *)
 | rec (e:exp) (e0:exp) (e1:exp) (*r Primitive recursion over nats *)
 | abs (t:typ) (e:exp) (*r Functions *)
 | fapp (e1:exp) (e2:exp) (*r Application *)
 | null : exp (*r Null tuple *)
 | pair (e1:exp) (e2:exp) (*r Ordered pair *)
 | fst (e:exp) (*r Left projection *)
 | snd (e:exp) (*r Right projection *)
 | abort (t:typ) (e:exp) (*r Abort *)
 | inl (t:typ) (e:exp) (*r Left injection *)
 | inr (t:typ) (e:exp) (*r Right injection *)
 | scase (e:exp) (e1:exp) (e2:exp) (*r Case analysis *).

(* EXPERIMENTAL *)
(** auxiliary functions on the new list types *)
(** library functions *)
(** subrules *)
(** arities *)
(** opening up abstractions *)
Fixpoint open_exp_wrt_exp_rec (k:nat) (e_5:exp) (e__6:exp) {struct e__6}: exp :=
  match e__6 with
  | (var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => var_b nat
        | inleft (right _) => e_5
        | inright _ => var_b (nat - 1)
      end
  | (var_f x) => var_f x
  | z => z 
  | (s e) => s (open_exp_wrt_exp_rec k e_5 e)
  | (rec e e0 e1) => rec (open_exp_wrt_exp_rec k e_5 e) (open_exp_wrt_exp_rec k e_5 e0) (open_exp_wrt_exp_rec (S k) e_5 e1)
  | (abs t e) => abs t (open_exp_wrt_exp_rec (S k) e_5 e)
  | (fapp e1 e2) => fapp (open_exp_wrt_exp_rec k e_5 e1) (open_exp_wrt_exp_rec k e_5 e2)
  | null => null 
  | (pair e1 e2) => pair (open_exp_wrt_exp_rec k e_5 e1) (open_exp_wrt_exp_rec k e_5 e2)
  | (fst e) => fst (open_exp_wrt_exp_rec k e_5 e)
  | (snd e) => snd (open_exp_wrt_exp_rec k e_5 e)
  | (abort t e) => abort t (open_exp_wrt_exp_rec k e_5 e)
  | (inl t e) => inl t (open_exp_wrt_exp_rec k e_5 e)
  | (inr t e) => inr t (open_exp_wrt_exp_rec k e_5 e)
  | (scase e e1 e2) => scase (open_exp_wrt_exp_rec k e_5 e) (open_exp_wrt_exp_rec (S k) e_5 e1) (open_exp_wrt_exp_rec (S k) e_5 e2)
end.

Definition open_exp_wrt_exp e_5 e__6 := open_exp_wrt_exp_rec 0 e__6 e_5.

(** terms are locally-closed pre-terms *)
(** definitions *)

(* defns LC_exp *)
Inductive lc_exp : exp -> Prop :=    (* defn lc_exp *)
 | lc_var_f : forall (x:tmvar),
     (lc_exp (var_f x))
 | lc_z : 
     (lc_exp z)
 | lc_s : forall (e:exp),
     (lc_exp e) ->
     (lc_exp (s e))
 | lc_rec : forall (e e0 e1:exp),
     (lc_exp e) ->
     (lc_exp e0) ->
      ( forall x , lc_exp  ( open_exp_wrt_exp e1 (var_f x) )  )  ->
     (lc_exp (rec e e0 e1))
 | lc_abs : forall (t:typ) (e:exp),
      ( forall x , lc_exp  ( open_exp_wrt_exp e (var_f x) )  )  ->
     (lc_exp (abs t e))
 | lc_fapp : forall (e1 e2:exp),
     (lc_exp e1) ->
     (lc_exp e2) ->
     (lc_exp (fapp e1 e2))
 | lc_null : 
     (lc_exp null)
 | lc_pair : forall (e1 e2:exp),
     (lc_exp e1) ->
     (lc_exp e2) ->
     (lc_exp (pair e1 e2))
 | lc_fst : forall (e:exp),
     (lc_exp e) ->
     (lc_exp (fst e))
 | lc_snd : forall (e:exp),
     (lc_exp e) ->
     (lc_exp (snd e))
 | lc_abort : forall (t:typ) (e:exp),
     (lc_exp e) ->
     (lc_exp (abort t e))
 | lc_inl : forall (t:typ) (e:exp),
     (lc_exp e) ->
     (lc_exp (inl t e))
 | lc_inr : forall (t:typ) (e:exp),
     (lc_exp e) ->
     (lc_exp (inr t e))
 | lc_scase : forall (e e1 e2:exp),
     (lc_exp e) ->
      ( forall x1 , lc_exp  ( open_exp_wrt_exp e1 (var_f x1) )  )  ->
      ( forall x2 , lc_exp  ( open_exp_wrt_exp e2 (var_f x2) )  )  ->
     (lc_exp (scase e e1 e2)).
(** free variables *)
Fixpoint fv_exp (e_5:exp) : vars :=
  match e_5 with
  | (var_b nat) => {}
  | (var_f x) => {{x}}
  | z => {}
  | (s e) => (fv_exp e)
  | (rec e e0 e1) => (fv_exp e) \u (fv_exp e0) \u (fv_exp e1)
  | (abs t e) => (fv_exp e)
  | (fapp e1 e2) => (fv_exp e1) \u (fv_exp e2)
  | null => {}
  | (pair e1 e2) => (fv_exp e1) \u (fv_exp e2)
  | (fst e) => (fv_exp e)
  | (snd e) => (fv_exp e)
  | (abort t e) => (fv_exp e)
  | (inl t e) => (fv_exp e)
  | (inr t e) => (fv_exp e)
  | (scase e e1 e2) => (fv_exp e) \u (fv_exp e1) \u (fv_exp e2)
end.

(** substitutions *)
Fixpoint subst_exp (e_5:exp) (x5:tmvar) (e__6:exp) {struct e__6} : exp :=
  match e__6 with
  | (var_b nat) => var_b nat
  | (var_f x) => (if eq_var x x5 then e_5 else (var_f x))
  | z => z 
  | (s e) => s (subst_exp e_5 x5 e)
  | (rec e e0 e1) => rec (subst_exp e_5 x5 e) (subst_exp e_5 x5 e0) (subst_exp e_5 x5 e1)
  | (abs t e) => abs t (subst_exp e_5 x5 e)
  | (fapp e1 e2) => fapp (subst_exp e_5 x5 e1) (subst_exp e_5 x5 e2)
  | null => null 
  | (pair e1 e2) => pair (subst_exp e_5 x5 e1) (subst_exp e_5 x5 e2)
  | (fst e) => fst (subst_exp e_5 x5 e)
  | (snd e) => snd (subst_exp e_5 x5 e)
  | (abort t e) => abort t (subst_exp e_5 x5 e)
  | (inl t e) => inl t (subst_exp e_5 x5 e)
  | (inr t e) => inr t (subst_exp e_5 x5 e)
  | (scase e e1 e2) => scase (subst_exp e_5 x5 e) (subst_exp e_5 x5 e1) (subst_exp e_5 x5 e2)
end.


(** definitions *)

(* defns JValue *)
Inductive value : exp -> Prop :=    (* defn value *)
 | val_z : 
     value z
 | val_s : forall (e:exp),
     value e ->
     value (s e)
 | val_abs : forall (t:typ) (e:exp),
     lc_exp (abs t e) ->
     value (abs t e)
 | val_null : 
     value null
 | val_prod : forall (e1 e2:exp),
     value e1 ->
     value e2 ->
     value (pair e1 e2)
 | val_inl : forall (t:typ) (e:exp),
     value e ->
     value (inl t e)
 | val_inr : forall (t:typ) (e:exp),
     value e ->
     value (inr t e).

(* defns JTyping *)
Inductive typing : env -> exp -> typ -> Prop :=    (* defn typing *)
 | typing_var : forall (G:env) (x:tmvar) (t:typ),
      uniq  G  ->
      binds  x   t   G  ->
     typing G (var_f x) t
 | typing_z : forall (G:env),
      uniq  G  ->
     typing G z typ_nat
 | typing_s : forall (G:env) (e:exp),
     typing G e typ_nat ->
     typing G (s e) typ_nat
 | typing_rec : forall (L:vars) (G:env) (e e0 e1:exp) (t:typ),
     typing G e typ_nat ->
     typing G e0 t ->
      ( forall x , x \notin  L  -> typing  (( x  ~  typ_nat ) ++  G )   ( open_exp_wrt_exp e1 (var_f x) )  (typ_arr t t) )  ->
      ( forall x , x \notin  L  -> value  ( open_exp_wrt_exp e1 (var_f x) )  )  ->
     typing G (rec e e0 e1) t
 | typing_abs : forall (L:vars) (G:env) (t1:typ) (e:exp) (t2:typ),
      ( forall x , x \notin  L  -> typing  (( x  ~  t1 ) ++  G )   ( open_exp_wrt_exp e (var_f x) )  t2 )  ->
     typing G (abs t1 e) (typ_arr t1 t2)
 | typing_fapp : forall (G:env) (e1 e2:exp) (t2 t1:typ),
     typing G e1 (typ_arr t1 t2) ->
     typing G e2 t1 ->
     typing G (fapp e1 e2) t2
 | typing_null : forall (G:env),
      uniq  G  ->
     typing G null typ_unit
 | typing_pair : forall (G:env) (e1 e2:exp) (t1 t2:typ),
     typing G e1 t1 ->
     typing G e2 t2 ->
     typing G (pair e1 e2) (typ_prod t1 t2)
 | typing_fst : forall (G:env) (e:exp) (t1 t2:typ),
     typing G e (typ_prod t1 t2) ->
     typing G (fst e) t1
 | typing_snd : forall (G:env) (e:exp) (t2 t1:typ),
     typing G e (typ_prod t1 t2) ->
     typing G (snd e) t2
 | typing_abort : forall (G:env) (t:typ) (e:exp),
     typing G e typ_void ->
     typing G (abort t e) t
 | typing_inl : forall (G:env) (t2:typ) (e:exp) (t1:typ),
     typing G e t1 ->
     typing G (inl t2 e) (typ_sum t1 t2)
 | typing_inr : forall (G:env) (t1:typ) (e:exp) (t2:typ),
     typing G e t2 ->
     typing G (inr t1 e) (typ_sum t1 t2)
 | typing_case : forall (L:vars) (G:env) (e e1 e2:exp) (t t1 t2:typ),
     typing G e (typ_sum t1 t2) ->
      ( forall x , x \notin  L  -> typing  (( x  ~  t1 ) ++  G )   ( open_exp_wrt_exp e1 (var_f x) )  t )  ->
      ( forall x , x \notin  L  -> typing  (( x  ~  t2 ) ++  G )   ( open_exp_wrt_exp e2 (var_f x) )  t )  ->
     typing G (scase e e1 e2) t.

(* defns JDyn *)
Inductive eval : exp -> exp -> Prop :=    (* defn eval *)
 | eval_s : forall (e e':exp),
     eval e e' ->
     eval (s e) (s e')
 | eval_fapp_left : forall (e1 e2 e1':exp),
     lc_exp e2 ->
     eval e1 e1' ->
     eval (fapp e1 e2) (fapp e1' e2)
 | eval_fapp_right : forall (e1 e2 e2':exp),
     value e1 ->
     eval e2 e2' ->
     eval (fapp e1 e2) (fapp e1 e2')
 | eval_beta : forall (t:typ) (e1 e2:exp),
     lc_exp (abs t e1) ->
     value e2 ->
     eval (fapp  ( (abs t e1) )  e2)  (open_exp_wrt_exp  e1   e2 ) 
 | eval_rec_scrut : forall (e e0 e1 e':exp),
     lc_exp (rec e e0 e1) ->
     lc_exp e0 ->
     eval e e' ->
     eval (rec e e0 e1) (rec e' e0 e1)
 | eval_rec_z : forall (e0 e1:exp),
     lc_exp (rec z e0 e1) ->
     lc_exp e0 ->
     eval (rec z e0 e1) e0
 | eval_rec_s : forall (e e0 e1:exp),
     lc_exp (rec  ( (s e) )  e0 e1) ->
     lc_exp e0 ->
     value  ( (s e) )  ->
     eval (rec  ( (s e) )  e0 e1) (fapp  (open_exp_wrt_exp  e1   e )   ( (rec e e0 e1) ) )
 | eval_pair_left : forall (e1 e2 e1':exp),
     lc_exp e2 ->
     eval e1 e1' ->
     eval (pair e1 e2) (pair e1' e2)
 | eval_pair_right : forall (e1 e2 e2':exp),
     value e1 ->
     eval e2 e2' ->
     eval (pair e1 e2) (pair e1 e2')
 | eval_fst : forall (e e':exp),
     eval e e' ->
     eval (fst e) (fst e')
 | eval_snd : forall (e e':exp),
     eval e e' ->
     eval (snd e) (snd e')
 | eval_fst_val : forall (e1 e2:exp),
     value e1 ->
     value e2 ->
     eval (fst (pair e1 e2)) e1
 | eval_snd_val : forall (e1 e2:exp),
     value e1 ->
     value e2 ->
     eval (snd (pair e1 e2)) e2
 | eval_abort : forall (t:typ) (e e':exp),
     eval e e' ->
     eval (abort t e) (abort t e')
 | eval_inl : forall (t:typ) (e e':exp),
     eval e e' ->
     eval (inl t e) (inl t e')
 | eval_inr : forall (t:typ) (e e':exp),
     eval e e' ->
     eval (inr t e) (inr t e')
 | eval_case : forall (e e1 e2 e':exp),
     lc_exp (scase e e1 e2) ->
     lc_exp (scase e e1 e2) ->
     eval e e' ->
     eval (scase e e1 e2) (scase e' e1 e2)
 | eval_casel : forall (t2:typ) (e e1 e2:exp),
     lc_exp (scase (inl t2 e) e1 e2) ->
     lc_exp (scase (inl t2 e) e1 e2) ->
     value e ->
     eval (scase (inl t2 e) e1 e2)  (open_exp_wrt_exp  e1   e ) 
 | eval_caser : forall (t1:typ) (e e1 e2:exp),
     lc_exp (scase (inr t1 e) e1 e2) ->
     lc_exp (scase (inr t1 e) e1 e2) ->
     value e ->
     eval (scase (inr t1 e) e1 e2)  (open_exp_wrt_exp  e2   e ) .


(** infrastructure *)
Hint Constructors value typing eval lc_exp.


