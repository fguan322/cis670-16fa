
{- =======================================================================================









                                    From Dynamic to Static or:
                          How I Learned to Stop worrying and Love the Type.


                                     Omar Navarro Leija









                                                                                        1

======================================================================================= -}{-
                                      Project Description



   Goal:
   Use Haskell's Typeable and Dynamic libraries to implement a simple dynamic language, Lang.


   Problem:
   Lang requires a lot of unnecessary casts and checks: All types must be checked to ensure
   they match. (Remember 'Dynamic Types' Chapter from PFPL?)


   Solution: We will compile Lang into StaticLang omitting as many uncessary dynamic checks
   as possible.








                                                                                        2

======================================================================================= -}{-
                                    Dynamic Types & You


   Dynamic typing requires runtime information about a program's types. At runtime, we must
   be able to check, compare, and branch based on types (Reflection).

   This is implemented in Haskell using the 'Typeable' typeclass.

   "A reflection on types", Simon Peyton Jones, et al. Revisted Haskell's Typeable
   reimplementing it using many of the newest GHC 8.0 extensions.

   Copied from the DataTypeable.hs: -}

{-# LANGUAGE
    RankNTypes, PolyKinds, TypeOperators, ScopedTypeVariables, GADTs,
    MultiParamTypeClasses, ConstraintKinds, FunctionalDependencies, FlexibleContexts,
    AllowAmbiguousTypes, FlexibleInstances, TypeInType, UndecidableInstances #-}{-

   "Type-safe reflection requires a very sophisticated type sytem indeed!"
      - A reflection on types



                                                                                        3

======================================================================================= -}{-
                                 Imports... Move Along...
-}
import DataTypeable
import DataDynamic
import Common
import Lang
import LangTest
import qualified Data.Map as Map
import Eval
import Data.Maybe














{-

======================================================================================= -}{-
                                 Typeable, Typeclass
-}

class Typeable_ (a :: k) where
   typeRep_ :: TypeRep a -- Typeable instances automatically generated for all types

-- Creating type representations.
myTr_ = typeRep
myTr2_ = typeRep :: TypeRep Int

trInt_ :: TypeRep Int
trInt_ = typeRep

-- Comparing types: type-aware equality.
data (a :: k1) ::~~: (b :: k2) where
  Refl_ :: forall k (a :: k). a ::~~: a

eqT_ :: forall k1 k2 (a :: k1) (b :: k2). TypeRep a -> TypeRep b -> Maybe (a :~~: b)
eqT_ = primitiveEqT

{-                                                                                      4

======================================================================================= -}{-
                                      Data.Dynamic

   Using Typeable we may now implement dynamic types in Haskell (with type safety!).    -}

-- Dynamic: A runtime representation of a type (as a TypeRep) and the object of that type.
data Dynamic_ where
  Dyn_ :: TypeRep a -> a -> Dynamic_

-- We can easily convert things to dynamics. Every type has an unique instace of Typeable
-- automatically generated by the compiler.
toDynamic_ :: Typeable a => a -> Dynamic
toDynamic_ x = Dyn typeRep x

-- Compare types of the given Dynamic value to the expected value. If they are the same
-- cast, else Nothing.
fromDynamic_ :: forall a. Typeable a => Dynamic -> Maybe a
fromDynamic_ (Dyn (rb :: TypeRep b) (x :: b)) = case
  eqT (typeRep :: TypeRep a) rb of
    Just Refl -> Just x
    Nothing   -> Nothing
{-                                                                                      5

======================================================================================= -}{-
                                      Language Lang                                     -}

data Exp_ where
  Lam_  :: String -> Exp_ -> Exp_           -- Function abstraction as \x . e
  (::@) :: Exp_ -> Exp_ -> Exp_             -- Function application (e1 e2)
  Bin_  :: BinOp -> Exp_ -> Exp_ -> Exp_    -- Binary operator
  Uni_  :: UniOp -> Exp_ -> Exp_            -- Unary operator
  Lit_  :: forall t. (LangType t) => t -> Exp_  -- literal
  Var_  :: String -> Exp_                   -- Variable
  If_   :: Exp_ -> Exp_ -> Exp_ -> Exp_     -- Conditional branching

data BinOp_ =
  Plus_ | Minus_ | Mult_ | Or_ | And_ | Lte_ | Gte_ | Lt_ | Gt_ |
  Eq_   | Add_   | Tup_

data UniOp_ =
  Not_ | Fst_ | Snd_ | Head_ | Tail_

class (Typeable a, Eq a, Show a) => LangType_ a

{-                                                                                      6

======================================================================================= -}{-
                                Sample Lang Programs
-}
-- We implement recursion through the Y combinator.
yComb_ :: Exp
yComb_ = Lam "f" (e :@ e)
         where e = Lam "x" (f :@ (x :@ x))

-- Factorial function.
fact_ :: Exp
fact_ = yComb :@ (Lam "f" (Lam "n"
                    (If (Uni Not (Bin Eq n zero))
                      (Bin Mult n (f :@ (Bin Minus n one)))
                      one)))

-- Like a real dynamic language!
dynamicTest_ :: Exp
dynamicTest_ = Bin Plus true zero





{-                                                                                       7

======================================================================================= -}{-
                                     Interpreter for Lang                               -}

evalExp_ :: Env -> Exp -> Dynamic
-- Create function over v, add v to our env and recurse on updated env.
evalExp_ env (Lam s e)  = toDynamic $ \ v -> evalExp (Map.insert s v env) e
evalExp_ env (e1 :@ e2) = gFromDynamic (evalExp env e1) (evalExp env e2)

evalExp_ env (Bin op e1 e2) = evalBin env op e1 e2
evalExp_ env (Uni op e)     = evalUni env op e

evalExp_ _   (Lit (n :: a)) = toDynamic n
-- Look up variable in our enviornment!
evalExp_ env (Var x) = fromMaybe (error err) $ Map.lookup x env
  where err = "Variable " ++ x ++ " not found in this enviornment."
-- b' must be converted to a bool.
evalExp_ env (If b e1 e2) = case gFromDynamic (evalExp env b) of
                             True   -> evalExp env e1
                             False  -> evalExp env e2
{-
  Most of the work is being done by evalBin and evalUni. Let's have a closer look.

                                                                                        8

======================================================================================= -}{-
                              Dynamic is hard to work with!                             -}

evalBin_ :: Env -> BinOp -> Exp -> Exp -> Dynamic
evalBin_ env Eq e1 e2 = toDynamic $ dynEq (evalExp env e1) (evalExp env e2)

-- Implement equality between two dynamic types. If the type of the arguments don't
-- match we throw an error.
dynEq_ :: Dynamic -> Dynamic -> Bool
dynEq_ d1@(Dyn tr1 obj1) d2@(Dyn tr2 obj2) =
    case eqT tr1 trInte of                                          -- Integers?
      Just Refl -> obj1 == gFromDynamic d2
      Nothing   -> -- Same for booleans, and chars...
        case (tupleUnify tr1, tupleUnify tr2) of                    -- Tuples?
          (Just (TupleRep t1 t2), Just (TupleRep t1' t2')) ->
            case (dynFst d1, dynFst d2, dynSnd d1, dynSnd d2) of
              (Just fd1, Just fd2, Just sd1, Just sd2) -> dynEq_ fd1 fd2 && dynEq_ sd1 sd2


-- List remain to be implemented.


{-                                                                                      9

======================================================================================= -}{-
                              Dynamic is hard to work with! (cont.)                     -}

-- Intuition: make sure that pab is a pair type, then call fst on it
dynFst_ :: Dynamic -> Maybe Dynamic
dynFst_ (Dyn rpab x) = do
  App rpa rb <- splitApp rpab
  App rp ra  <- splitApp rpa
  Refl       <- eqT rp (typeRep :: TypeRep (,))
  return (Dyn ra (fst x))

data TupleRep_ t where
  TupleRep_ :: TypeRep a -> TypeRep b -> TupleRep_ (a, b)

tupleUnify_ :: TypeRep t -> Maybe (TupleRep t)
tupleUnify_ tra = do
  (App tra' tra2) <- splitApp tra
  (App tr tra1) <- splitApp tra'
  Refl <- eqT tr (typeRep :: TypeRep (,))
  return $ TupleRep tra1 tra2
{-                                                                                      10

======================================================================================= -}{-

Too many imports in the namespace. Switching to another file :) -}
